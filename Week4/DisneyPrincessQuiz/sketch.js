/*
 *
 * This program is a personality quiz to determine which Disney Princess you are most like. It reads from a json file for the quiz copy.
 *
 * Disclaimer: The json was generated by AI, including questions, princesses etc.
 */

//var to store json config in.
let quizData;
//application has 3 states, intro, answering and results, rendered content changes based on the state.
let state = "intro";
//tracks which question user is currently answering.
let currentQuestionIndex = 0;
// this array represents the answers to the current question. storing the buttons as a global array helps prevent bugs where a click from the previous frame is registered in the next frame on the next question
let currentButtons = [];
//each answer maps to a princess name. this array stores those names that correspond to the user's answers. the frequency of a name in this array will be how we determine the winning princess.
let princessAnswers = [];
//this dictionary will store the image urls for the princesses. the key name will be the princess name, with the value being the url path.
let princessImages = {};

//vertical spacing between each button.
const buttonSpacing = 10;
//global colour of text
const textColour = "#3e2139";
const backgroundColour = "#ffb5c0";

//array to hold stars for mouse trail
let starryTrail = [];
//controlls the alpha for the starry trail
let starryAlpha = 0;

//reference for buttons: https://editor.p5js.org/Fei_Wang1121/sketches/q9k6P-vM9
//reference for json: https://p5js.org/reference/p5/loadJSON/
function preload() {
  //load json quiz metadata
  quizData = loadJSON("quizMetadata.json");

  //load all princess images.
  princessImages["ariel"] = loadImage("images/ariel.webp");
  princessImages["belle"] = loadImage("images/belle.webp");
  princessImages["mulan"] = loadImage("images/mulan.webp");
  princessImages["rapunzel"] = loadImage("images/rapunzel.webp");
  princessImages["tiana"] = loadImage("images/tiana.png");
  princessImages["moana"] = loadImage("images/moana.png");
}

function setup() {
  //set to size of browser window
  createCanvas(windowWidth, windowHeight);
}

function draw() {
  background(backgroundColour);

  //if/else if/else conditions used to determine which view we render.
  if (state === "intro") {
    drawIntro();
  } else if (state === "answering") {
    //question/progress tracking.
    //as indexes start on 0, but we start counting on 1 as humans, increment the index by one so it makes sense to the user.
    const visualIndex = currentQuestionIndex + 1;

    text(
      "Question " + visualIndex + " of " + quizData.quiz.questions.length,
      width - 100,
      30
    );
    //question and answer buttons
    drawQuestion();
  } else if (state === "results") {
    drawResults();
  } else {
    //in theory we should never reach this branch - but good to cover it - and if we do theres a little bit of user feedback as text!
    text("üòê you shouldn't be here...refresh the page ", width / 2, height / 2);
  }

  //EXTRA SPARKLES!!
  //adding a starry mouse trail
  //reference: https://editor.p5js.org/mrbombmusic/sketches/Sy7H6GmDm

  //add the mouse position coords to array.
  starryTrail.push([mouseX, mouseY]);
  //loop through the array of coords to draw the stars in those locations.
  for (let i = 0; i < starryTrail.length; i++) {
    text("‚≠ê", starryTrail[i][0], starryTrail[i][1]);
    //fade out the stars over time, and remove them from the array when fully faded
    if (starryAlpha > 255) {
      starryTrail.shift();
      starryAlpha = 0;
    }
    //increment alpha, higher the increment the quicker the lifecycle of the stars as the quicker theyll fade.
    starryAlpha += 30;
  }
}


//this draws the landing screen, just some text with what to expect. 
function drawIntro() { 
  textAlign(CENTER);
  textSize(32);
  fill(textColour);

  //targeting json for title and description of quiz. 
  text(quizData.quiz.title, width / 2, height / 2 - 40);
  textSize(16);
  text(quizData.quiz.description, width / 2, height / 2);
  textStyle(BOLD);
  text("Click anywhere to start the quiz!", width / 2, height / 2 + 40);
  textStyle(NORMAL);  //reset so bold doesn't persist 
}


function drawQuestion() {
  //fetching current question from json
    let question = quizData.quiz.questions[currentQuestionIndex];
  textSize(24);
  fill(textColour);
  //getting text from the json object we fetched. 
  text(question.question, width / 2, 100);
  textSize(16);
  //invalidate the previous buttons. Have to do this because of how the canvas is redrawn every frame, it was causing multiple clicks to register on the next question
  currentButtons = [];

  for (let j = 0; j < question.answers.length; j++) {
  //for each answer in the json, draw a button. button is defined by a custom class below. 
    let answer = question.answers[j];
    let buttonWidth = windowWidth - 100;
    let buttonHeight = 40;
    let buttonX = 50;
    let buttonY = 150 + j * (buttonHeight + buttonSpacing);
    //creating the button class, handles rendering, styling and click/hover logic
    let answerButton = new AnswerButton(buttonX, buttonY, buttonWidth, buttonHeight, answer.text, () => {
      //button click logic, this pararm is a function type, so we're defining the function logic here. 
      console.log("pushing answer: " + answer.princess);
     //add princess name to the answers array
      princessAnswers.push(answer.princess);
      //increment the index of the current question to move to the next. 
      currentQuestionIndex++;
      //if we've reached the end of the questions, change state to 'results' so we can see what disney princess we've matched with. 
      if (currentQuestionIndex >= quizData.quiz.questions.length) {
        console.log("quiz is over" + princessAnswers);
        state = "results";
      }
    });
    //button rendering logic. 
    answerButton.display();
    //add the button to the global array of buttons. 
    currentButtons.push(answerButton);
  }
}


//final screen.- big finale - the results! 
function drawResults() {
  //this will return a map of [princess name, frequency] pairs, sorted from most to least frequent
  let princessFrequency = getMostFrequentAnswer();
  //get the winning princess name by getting the first key in the map, as its sorted from within the function we know the first index will be the most frequent. 
  let winningPrincess = Object.keys(princessFrequency)[0].toLowerCase();//good to lowercase to make string comparisons more accurate. 
  
  //assigning positionings and sizes to display the princess imag.e 
  let princessHeight = height/2;
let princessWidth = width/2;
let imgx = width/2 ;
let imgy = princessHeight/2 + 20;
  imageMode(CENTER);
  
  
      //big long if else chain - there are other ways to do this, 
    //like switch, or include image into princess data in the json, 
    //or simplest is use the winningPrincess var directly as the key name to access the princessImages url
    //but this weeks about if else statements, so lets do it this way!
   if (winningPrincess === "ariel") {
    image(princessImages["ariel"], imgx, imgy, princessWidth, princessHeight, 0, 0, princessImages["ariel"].width, princessImages["ariel"].height, CONTAIN);
  } else if (winningPrincess === "belle") {
    image(princessImages["belle"], imgx, imgy, princessWidth, princessHeight, 0, 0, princessImages["belle"].width, princessImages["belle"].height, CONTAIN);
  } else if (winningPrincess === "mulan") {
    image(princessImages["mulan"], imgx, imgy, princessWidth, princessHeight, 0, 0, princessImages["mulan"].width, princessImages["mulan"].height, CONTAIN);
  } else if (winningPrincess === "rapunzel") {
    image(princessImages["rapunzel"], imgx, imgy, princessWidth, princessHeight, 0, 0, princessImages["rapunzel"].width, princessImages["rapunzel"].height, CONTAIN);
  } else if (winningPrincess === "tiana") {
    image(princessImages["tiana"], imgx, imgy, princessWidth, princessHeight, 0, 0, princessImages["tiana"].width, princessImages["tiana"].height, CONTAIN);
  } else if (winningPrincess === "moana") {
    image(princessImages["moana"], imgx, imgy, princessWidth, princessHeight, 0, 0, princessImages["moana"].width, princessImages["moana"].height, CONTAIN);
  }
  
  //bit of text to wrap things up 
    textAlign(CENTER);
  textSize(32);
  fill(textColour);
  textStyle(BOLD);
  text("Quiz Completed!", width / 2, princessHeight + 100);
  textSize(16);
  let percenteLikeness = ((princessFrequency[winningPrincess] / quizData.quiz.questions.length) * 100).toFixed(0);
  text("You are " + percenteLikeness + "% like " + toSentenceCase(winningPrincess), width / 2, princessHeight + 130);
  textStyle(NORMAL);  //reset

  //princess description - accessing from json with the princess name, the princess name is the id of the json princess object,
  //so find the object where the name matches the id and get its description property
  console.log("quiz princesses: "  + JSON.stringify(quizData.quiz.princesses));
  let princessData = quizData.quiz.princesses.find(p => p.id === winningPrincess);
  text(princessData ? princessData.description : "Princess not found", width / 2, princessHeight + 170);

  text("Refresh the page to retake the quiz!", width / 2, height - 40);
}


/****Interaction****/
function mousePressed() {
  if (state === "intro") { 
    //clicking when on intro will swap the state to 'answering'
        state = "answering";
    } else if (state === "answering") {
    //handle the button presses for the currentButton array in here.
    //instead of an indexed for loop, we're using a for object loop to iterate through the array
    for (let button of currentButtons) {
      //check if we're within the button bounds using its mouseover function which will check its own coords against the mouse. 
      if (button.isMouseOver()) {
        console.log("button clicked: " + button.label);
        cursor('pointer');
        button.action();
        break; // Exit after first button click
      } else {
        cursor('default');
      }
    }
  } else if (state === "results") {
    //do nothing. quiz is over.
  }
}

//recalculates the canvas when the browser window changes, keeps responsiv.e
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

/****Utility****/
//this function goes through the answers array, and returns a map of [name, frequency] pairs
//this wil give us the disney princess that the user is most like, then we can display the runner ups after too.

function getMostFrequentAnswer() {
  //define empty map
  let frequency = {};
  //loop through answers
  for (let princess of princessAnswers) {
    //if the answer text is already in the map, increment its count
    if (frequency[princess]) {
      frequency[princess]++;
    } else {
      //otherwise add it with a count of 1 because its the first time we've processed this princess value.
      frequency[princess] = 1;
    }
  }

  //sorting the map by most to least occurances
  console.log("unsorted frequency: " + JSON.stringify(frequency));
  let sortedFrequency = Object.entries(frequency).sort((a, b) => b[1] - a[1]);
  console.log("sorted frequency: " + JSON.stringify(sortedFrequency));
  //convert sorted array back to object format and return it
  let sortedFrequencyObject = Object.fromEntries(sortedFrequency);
  return sortedFrequencyObject;
}

//utility function to convert a string to a sentence case format, but uppercasing the first character and lowercasing the remaining ones.
function toSentenceCase(value) {
  return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
}

//custom classes for button which allows for better code structure and click handling. 
class AnswerButton {
  constructor(x, y, w, h, label, action) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.label = label;
    this.action = action;
  }
  
  display() {
    stroke('#e496af');
    if (this.isMouseOver()) {
      fill('#e496af');
    } else {
      fill('#f4d3d9');
    }
    rect(this.x, this.y, this.w, this.h, 10); //rounded corners, 10r 
    fill(textColour);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(16);
    text(this.label, this.x + this.w / 2, this.y + this.h / 2);
  }
  
  isMouseOver() {
    //calculate if the mouse is over the button
    let isOver = mouseX > this.x && mouseX < this.x + this.w && mouseY > this.y && mouseY < this.y + this.h;
    return isOver;
  }
}


